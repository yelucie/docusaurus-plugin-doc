import React from 'react';

# Markdown transformers

Transformers are the **bridge** between your WYSIWYG editor and markdown. They define how content is converted when **importing markdown** into the editor, and **exporting editor components** back to markdown.

This guide shows you how to build **custom transformers** in the plugin.

<div style={{textAlign: 'center', margin: '20px 0'}}>
  <img 
    src="/docusaurus-plugin-doc/vid/highlight.gif" 
    alt="Transformer highlight tutorial demo"
    style={{
      maxWidth: '100%',
      height: 'auto',
      borderRadius: '8px',
      boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
      display: 'block',
      margin: '0 auto'
    }}
  />
  <p style={{fontSize: '14px', color: '#666', marginTop: '8px'}}>
    <em>Watch transformers convert markdown syntax into interactive components</em>
  </p>
</div>


## Prerequisites

Before creating custom transformers, ensure you understand:

- TypeScript knowledge and familiarity with [regular expressions](https://developer.mozilla.org/docs/Web/JavaScript/Guide/Regular_expressions)
- Understanding of this [plugin's markdown processing system](./markdown-processing.md)
- Basic knowledge of [Lexical's node system](./custom-node-development.md)

## Choose your transformer type

Determine which transformer type fits your needs:

| Type                                                                                                                   | Use Case                                 |
| ---------------------------------------------------------------------------------------------------------------------- | ---------------------------------------- |
| [**`TextFormatTransformer`**](https://lexical.dev/docs/api/modules/lexical_markdown#textformattransformer)             | Simple inline formatting with delimiters |
| [**`TextMatchTransformer`**](https://lexical.dev/docs/api/modules/lexical_markdown#textmatchtransformer)               | Pattern-based component replacements     |
| [**`ElementTransformer`**](https://lexical.dev/docs/api/modules/lexical_markdown#elementtransformer)                   | Single-line block elements               |
| [**`MultilineElementTransformer`**](https://lexical.dev/docs/api/modules/lexical_markdown#multilineelementtransformer) | Multi-line block elements                |

## Creating a text format transformer

<u>**Use case**</u>: Adding custom inline formatting like strikethrough.

### Step 1: Define the transformer

```ts title="src/theme/plugins/MarkdownTransformers/myTransformers.ts"
import { TextFormatTransformer } from "@lexical/markdown";

export const DOUBLE_STRIKETHROUGH: TextFormatTransformer = {
  format: ["strikethrough"],
  tag: "~~",
  type: "text-format",
};
```

### Step 2: Register the transformer

```ts title="src/theme/plugins/MarkdownTransformers/index.ts"
import { TRANSFORMERS } from "@lexical/markdown";
import { DOUBLE_STRIKETHROUGH } from "./myTransformers";

export const transformers = [
    DOUBLE_STRIKETHROUGH
    ...TRANSFORMERS,
];
```

<u>**Result**</u>

`~~text~~` becomes, in the editor: , in the editor: ~~text~~.

## Creating a text match transformer

<u>**Use case**</u>: Rendering pattern-based component like math expressions.

### Step 1: Define regex patterns

```ts title="src/theme/utils/regExp.ts"
export const EQUATION_REGEX = /\$([^$]+?)\$/;
export const EQUATION_INLINE_INPUT_REGEX = /\$([^$]+?)\$$/;
```

### Step 2: Implement export function

```ts title="src/theme/plugins/MarkdownTransformers/myTransformers.ts"
import { EquationNode } from "@theme/nodes/EquationNode";

function equationExport(node: EquationNode): string {
  return `$${node.getEquation()}$`;
}
```

### Step 3: Implement replace function

```ts title="src/theme/plugins/MarkdownTransformers/myTransformers.ts"
import { TextMatchTransformer } from "@lexical/markdown";
import { $createEquationNode } from "@theme/nodes/EquationNode";

function equationReplace(): TextMatchTransformer["replace"] {
  return (textNode, match) => {
    const [, equation] = match;
    const equationNode = $createEquationNode(equation, true);
    textNode.replace(equationNode);
  };
}
```

### Step 4: Create the transformer

```ts title="src/theme/plugins/MarkdownTransformers/myTransformers.ts"
import { TextMatchTransformer } from "@lexical/markdown";
import { $isEquationNode, EquationNode } from "@theme/nodes/EquationNode";
import { EQUATION_REGEX, EQUATION_INPUT_REGEX } from "@theme/utils/regExp";

export const EQUATION: TextMatchTransformer = {
  dependencies: [EquationNode],
  export: (node) => {
    return $isEquationNode ? equationExport(node) : null;
  },
  importRegExp: EQUATION_REGEX,
  regExp: EQUATION_INPUT_REGEX,
  replace: equationReplace(),
  trigger: "$",
  type: "text-match",
};
```

### Step 5: Register the transformer

```ts title="src/theme/plugins/MarkdownTransformers/index.ts"
import { TRANSFORMERS } from "@lexical/markdown";
import { EQUATION } from "./myTransformers";

const transformers = [
    ...TRANSFORMERS, 
    EQUATION
];
```

<u>**Result**</u>

`$f(x)=2x$` becomes, in the editor:  $f(x)=2x$.

## Creating an element Transformer

<u>**Use case**</u>: Converting single-line block elements like horizontal rules.

### Step 1: Define the regex

```ts title="src/theme/utils/regExp.ts"
export const HR_REGEX = /^(-{3,}|\*{3,}|_{3,})\s?$/;
```

### Step 2: Implement export function

```ts title="src/theme/plugins/MarkdownTransformers/myTransformers.ts"
function hrExport(): string {
  return `***`;
}
```

### Step 3: Implement replace function

```ts title="src/theme/plugins/MarkdownTransformers/myTransformers.ts"
import { ElementTransformer } from "@lexical/markdown";
import { $createHorizontalRuleNode } from "@lexical/react/LexicalHorizontalRuleNode";

function hrReplace(): ElementTransformer["replace"] {
  return (parentNode, _1, _2, isImport) => {
    const line = $createHorizontalRuleNode();

    if (isImport || parentNode.getNextSibling() != null) {
      parentNode.replace(line);
    } else {
      parentNode.insertBefore(line);
    }

    line.selectNext();
  };
}
```

### Step 4: Create the transformer

```ts title="src/theme/plugins/MarkdownTransformers/myTransformers.ts"
import { ElementTransformer } from "@lexical/markdown";
import { $isHorizontalRuleNode } from "@lexical/react/LexicalHorizontalRuleNode";
import { HR_REGEX } from "@theme/utils/regExp";

export const HR: ElementTransformer = {
  dependencies: [HorizontalRuleNode],
  export: (node: LexicalNode) => {
    return $isHorizontalRuleNode(node) ? hrExport() : null;
  },
  regExp: HR_REGEX,
  replace: hrReplace(),
  type: "element",
};
```

### Step 5: Register the transformer

```ts title="src/theme/plugins/MarkdownTransformers/index.ts"
import { TRANSFORMERS } from "@lexical/markdown";
import { HR } from "./myTransformers";

const transformers = [
    ...TRANSFORMERS, 
    HR
];
```

<u>**Result**</u>

`***` becomes, in the editor:

---

## Creating a Multiline Element Transformer

<u>**Use case**</u>: Converting multiline block elements like admonitions (callouts).

### Step 1: Define regex patterns

```ts title="src/theme/utils/regExp.ts"
export const ADMONITION_START_REGEX = /^[ \t]*:::(\w+)(?:\(([^)]+)\)|\[([^\]]+)]| ([^\n]+))?/;
export const ADMONITION_END_REGEX = /^[ \t]*:::[ \t]*$/m;
```

### Step 2: Implement export function

```ts title="src/theme/plugins/MarkdownTransformers/myTransformers.ts"
import { AdmonitionNode } from "@theme/nodes/AdmonitionNode";

function admonitionExport(node: AdmonitionNode): string {
    const children = node.getChildren();
    const admonitionType = node.getAdmonitionType();
    const title = node.getTitle();

    return `:::${admonitionType}${title && title !== '' ? `[${title}]` : ''}\n${children}\n:::\n`;
}
```

### Step 3: Implement replace function

```ts title="src/theme/plugins/MarkdownTransformers/myTransformers.ts"
import { ElementTransformer } from "@lexical/markdown";
import { $createHorizontalRuleNode } from "@lexical/react/LexicalHorizontalRuleNode";

function admonitionReplace(): MultilineElementTransformer["replace"] {
  return (rootNode, _children, startMatch, _endMatch, linesInBetween) => {
    let admonitionNode: AdmonitionNode;
    let content;

    // Extract admonition type and title from the start tag match
    const admonitionType = startMatch[1]; // e.g., "info", "note", "warning"
    const title = startMatch[3] || startMatch[4] || ''; // Title might be in different capture groups

    if (linesInBetween) {
      // Case 1: Single line content - simple processing
      if (linesInBetween.length === 1) {
        // Remove a single leading space if present (common in markdown syntax)
        content = linesInBetween[0].startsWith(' ')
          ? linesInBetween[0].slice(1)
          : linesInBetween[0];
      }
      // Case 2: Multi-line content - needs more complex processing
      else {
        // Handle the first line
        if (linesInBetween[0].trim().length === 0) {
          // If first line is empty, remove all empty lines from the beginning
          while (linesInBetween.length > 0 && !linesInBetween[0].length) {
            linesInBetween.shift();
          }
        } else {
          // If first line has content, remove a single leading space if present
          linesInBetween[0] = linesInBetween[0].startsWith(' ')
            ? linesInBetween[0].slice(1)
            : linesInBetween[0];
        }

        // Remove all empty lines from the end of the content
        while (
          linesInBetween.length > 0 &&
          !linesInBetween[linesInBetween.length - 1].length
        ) {
          linesInBetween.pop();
        }

        // Join all remaining lines into a single string with line breaks
        content = linesInBetween.join('\n');
      }

      admonitionNode = $createAdmonitionNode(content, admonitionType, title);
      rootNode.append(admonitionNode);
    }
    // If no lines in between (empty admonition), nothing is created
  },
  type: 'multiline-element',
}
```

### Step 4: Create the transformer

```ts title="src/theme/plugins/MarkdownTransformers/myTransformers.ts"
import { $isAdmonitionNode, EquationNode } from "@theme/nodes/EquationNode";
import { ADMONITION_START_REGEX, ADMONITION_END_REGEX } from "@theme/utils/regExp";

export const ADMONITION: ElementTransformer = {
  dependencies: [AdmonitionNode],
  export: (node: LexicalNode) => {
    return $isAdmonitionNode(node) ? admonitionExport() : null;
  },
  regExpEnd: {
    optional: true, // The admonition might not have ending regex
    regExp: ADMONITION_END_REGEX,
  },
  regExpStart: ADMONITION_START_REGEX,
  replace: admonitionReplace(),
  type: "multiline-element",
};
```

### Step 5: Register the transformer

```ts title="src/theme/plugins/MarkdownTransformers/index.ts"
import { TRANSFORMERS } from "@lexical/markdown";
import { ADMONITION } from "./myTransformers";

const transformers = [
    ...TRANSFORMERS, 
    ADMONITION
];
```

<u>**Result**</u>

```
:::tip
Let's edit this component!
:::
```

becomes, in the editor:

:::tip
Let's edit this component!
:::

## Testing Your Transformers

### Step 1: Create test cases

```ts title="src/transformers/__tests__/MyTransformers.test.ts"
import { $convertFromMarkdownString } from "@lexical/markdown";
import { MY_TRANSFORMERS } from "../config/transformers";

test('double strikethrough transformer', () => {
  const markdown = "This is ~~strikethrough~~ text";
  const editorState = $convertFromMarkdownString(markdown, MY_TRANSFORMERS);
  // Add assertions
});
```

### Step 2: Test in your editor

1. Start your development server
2. Type your transformer syntax
3. Verify the transformation works
4. Test export back to markdown

## Troubleshooting Common Issues

**Transformer not working?**
- Check if dependencies are properly imported
- Verify regex patterns match your input
- Ensure transformer is included in the transformers array

**Export not working correctly?**
- Implement proper type checking in export function
- Handle edge cases in your export logic
- Test with various node configurations

## Next Steps

- Learn about [Custom Node Development](./custom-node-development.md) to create the nodes your transformers use
- Explore [Plugin Architecture](./plugin-architecture.md) for deeper integration
- Check [Markdown Processing](./markdown-processing.md) to understand the transformation pipeline
